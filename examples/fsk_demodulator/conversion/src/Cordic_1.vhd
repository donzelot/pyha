-- generated by pyha 0.0.0 at 2017-03-01 00:53:26
library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;
    use ieee.fixed_float_types.all;
    use ieee.fixed_pkg.all;
    use ieee.math_real.all;

library work;
    use work.ComplexTypes.all;
    use work.PyhaUtil.all;
    use work.all;

-- CORDIC algorithm.
-- readable paper -> http://www.andraka.com/files/crdcsrvy.pdf
-- :param iterations: resource/ precision trade off
-- :param mode: vectoring or rotation
package Cordic_1 is
    type CordicMode is (VECTORING,ROTATION);
    type sfixed1_16_list_t is array (natural range <>) of sfixed(1 downto -16);
    type sfixed0_24_list_t is array (natural range <>) of sfixed(0 downto -24);

    type next_t is record
        iterations: integer;
        x: sfixed1_16_list_t(0 to 13);
        y: sfixed1_16_list_t(0 to 13);
        phase: sfixed0_24_list_t(0 to 13);
    end record;

    type self_t is record
        -- constants
        mode: CordicMode;
        phase_lut_fix: sfixed0_24_list_t(0 to 13);
        \_delay\: integer;

        iterations: integer;
        x: sfixed1_16_list_t(0 to 13);
        y: sfixed1_16_list_t(0 to 13);
        phase: sfixed0_24_list_t(0 to 13);
        \next\: next_t;
    end record;

    procedure \_pyha_constants_self\(self: inout self_t);

    procedure \_pyha_reset_self\(self: inout self_t);

    procedure \_pyha_update_self\(self: inout self_t);

    -- Runs one step of pipelined CORDIC
    -- Returned phase is in 1 to -1 range
    procedure main(self:inout self_t; x: sfixed(1 downto -16); y: sfixed(1 downto -16); phase: sfixed(0 downto -24); ret_0:out sfixed(1 downto -16); ret_1:out sfixed(1 downto -16); ret_2:out sfixed(0 downto -24));

    -- CORDIC works in only 1 quadrant, this performs hacks to make it usable on other qudrants as well.
    procedure initial_step(self:inout self_t; phase: sfixed(0 downto -24); x: sfixed(1 downto -16); y: sfixed(1 downto -16));

    -- Core combinatory part, this will be pipeline
    -- :param i: current pipeline step
    -- :param adj: phase adjustment
    procedure pipeline_step(self:inout self_t; i: integer; x: sfixed(1 downto -16); y: sfixed(1 downto -16); p: sfixed(0 downto -24); adj: sfixed(0 downto -24); ret_0:out sfixed(1 downto -16); ret_1:out sfixed(1 downto -16); ret_2:out sfixed(0 downto -24));
end package;

package body Cordic_1 is
    procedure \_pyha_constants_self\(self: inout self_t) is
    begin
        self.mode := VECTORING;
        self.phase_lut_fix := (Sfix(0.25, 0, -24), Sfix(0.14758361765043326, 0, -24), Sfix(0.07797913037736932, 0, -24), Sfix(0.039583424160565546, 0, -24), Sfix(0.01986852430554084, 0, -24), Sfix(0.009943947823589275, 0, -24), Sfix(0.0049731872789504136, 0, -24), Sfix(0.0024867453936697394, 0, -24), Sfix(0.0012433916687141005, 0, -24), Sfix(0.0006216982059233716, 0, -24), Sfix(0.0003108493994100204, 0, -24), Sfix(0.00015542473676113155, 0, -24), Sfix(7.771237301258342e-05, 0, -24), Sfix(3.8856187085293995e-05, 0, -24));
        self.\_delay\ := 14;

    end procedure;

    procedure \_pyha_reset_self\(self: inout self_t) is
    begin
        self.\next\.iterations := 14;
        self.\next\.x := (Sfix(0.0, 1, -16), Sfix(0.0, 1, -16), Sfix(0.0, 1, -16), Sfix(0.0, 1, -16), Sfix(0.0, 1, -16), Sfix(0.0, 1, -16), Sfix(0.0, 1, -16), Sfix(0.0, 1, -16), Sfix(0.0, 1, -16), Sfix(0.0, 1, -16), Sfix(0.0, 1, -16), Sfix(0.0, 1, -16), Sfix(0.0, 1, -16), Sfix(0.0, 1, -16));
        self.\next\.y := (Sfix(0.0, 1, -16), Sfix(0.0, 1, -16), Sfix(0.0, 1, -16), Sfix(0.0, 1, -16), Sfix(0.0, 1, -16), Sfix(0.0, 1, -16), Sfix(0.0, 1, -16), Sfix(0.0, 1, -16), Sfix(0.0, 1, -16), Sfix(0.0, 1, -16), Sfix(0.0, 1, -16), Sfix(0.0, 1, -16), Sfix(0.0, 1, -16), Sfix(0.0, 1, -16));
        self.\next\.phase := (Sfix(0.0, 0, -24), Sfix(0.0, 0, -24), Sfix(0.0, 0, -24), Sfix(0.0, 0, -24), Sfix(0.0, 0, -24), Sfix(0.0, 0, -24), Sfix(0.0, 0, -24), Sfix(0.0, 0, -24), Sfix(0.0, 0, -24), Sfix(0.0, 0, -24), Sfix(0.0, 0, -24), Sfix(0.0, 0, -24), Sfix(0.0, 0, -24), Sfix(0.0, 0, -24));
        \_pyha_update_self\(self);
    end procedure;

    procedure \_pyha_update_self\(self: inout self_t) is
    begin
        self.iterations := self.\next\.iterations;
        self.x := self.\next\.x;
        self.y := self.\next\.y;
        self.phase := self.\next\.phase;
        \_pyha_constants_self\(self);
    end procedure;



    -- Runs one step of pipelined CORDIC
    -- Returned phase is in 1 to -1 range
    procedure main(self:inout self_t; x: sfixed(1 downto -16); y: sfixed(1 downto -16); phase: sfixed(0 downto -24); ret_0:out sfixed(1 downto -16); ret_1:out sfixed(1 downto -16); ret_2:out sfixed(0 downto -24)) is

    begin
        initial_step(self, phase, x, y);

        for i in 0 to (self.phase_lut_fix'length - 1) - 1 loop
            pipeline_step(self, i, self.x(i), self.y(i), self.phase(i), self.phase_lut_fix(i), ret_0=>self.\next\.x(i + 1), ret_1=>self.\next\.y(i + 1), ret_2=>self.\next\.phase(i + 1));

        end loop;
        ret_0 := self.x(self.x'length-1);
        ret_1 := self.y(self.y'length-1);
        ret_2 := self.phase(self.phase'length-1);
        return;
    end procedure;

    -- CORDIC works in only 1 quadrant, this performs hacks to make it usable on other qudrants as well.
    procedure initial_step(self:inout self_t; phase: sfixed(0 downto -24); x: sfixed(1 downto -16); y: sfixed(1 downto -16)) is

    begin
        self.\next\.x(0) := x;
        self.\next\.y(0) := y;
        self.\next\.phase(0) := phase;
        if self.mode = ROTATION then
            if phase > 0.5 then
                -- > np.pi/2
                self.\next\.x(0) := resize(-x, size_res=>x);
                self.\next\.phase(0) := resize(phase - 1.0, size_res=>phase);
            elsif phase < -0.5 then
                -- < -np.pi/2
                self.\next\.x(0) := resize(-x, size_res=>x);
                self.\next\.phase(0) := resize(phase + 1.0, size_res=>phase);

            end if;
        elsif self.mode = VECTORING then
            if x < 0.0 and y > 0.0 then
                -- vector in II quadrant -> initial shift by PI to IV quadrant (mirror)
                self.\next\.x(0) := resize(-x, size_res=>x);
                self.\next\.y(0) := resize(-y, size_res=>y);
                self.\next\.phase(0) := Sfix(1.0, phase);
            elsif x < 0.0 and y < 0.0 then
                -- vector in III quadrant -> initial shift by -PI to I quadrant (mirror)
                self.\next\.x(0) := resize(-x, size_res=>x);
                self.\next\.y(0) := resize(-y, size_res=>y);
                self.\next\.phase(0) := Sfix(-1.0, phase);

            end if;
        end if;
    end procedure;

    -- Core combinatory part, this will be pipeline
    -- :param i: current pipeline step
    -- :param adj: phase adjustment
    procedure pipeline_step(self:inout self_t; i: integer; x: sfixed(1 downto -16); y: sfixed(1 downto -16); p: sfixed(0 downto -24); adj: sfixed(0 downto -24); ret_0:out sfixed(1 downto -16); ret_1:out sfixed(1 downto -16); ret_2:out sfixed(0 downto -24)) is
        variable direction: boolean;
        variable next_x: sfixed(1 downto -16);
        variable next_y: sfixed(1 downto -16);
        variable next_phase: sfixed(0 downto -24);
    begin
        if self.mode = ROTATION then
            direction := p > 0;
        elsif self.mode = VECTORING then
            direction := y < 0;

        end if;
        if direction then
            next_x := resize(x - (y sra i), size_res=>x, overflow_style=>fixed_wrap);
            next_y := resize(y + (x sra i), size_res=>y, overflow_style=>fixed_wrap);
            next_phase := resize(p - adj, size_res=>p, overflow_style=>fixed_wrap);
        else
            next_x := resize(x + (y sra i), size_res=>x, overflow_style=>fixed_wrap);
            next_y := resize(y - (x sra i), size_res=>y, overflow_style=>fixed_wrap);
            next_phase := resize(p + adj, size_res=>p, overflow_style=>fixed_wrap);
        end if;
        ret_0 := next_x;
        ret_1 := next_y;
        ret_2 := next_phase;
        return;

    end procedure;
end package body;
