-- generated by pyha 0.0.7
library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;
    use ieee.fixed_float_types.all;
    use ieee.fixed_pkg.all;
    use ieee.math_real.all;

library work;
    use work.complex_pkg.all;
    use work.PyhaUtil.all;
    use work.Typedefs.all;
    use work.all;
    use work.MovingAverage_0.all;

-- Filter out DC component, based on: https://www.dsprelated.com/showarticle/58.php
-- Deviation from the article that there is no delay matching, which in my opinion is ~useless as the DC component is more or less stable.
package DCRemoval_0 is
    type self_t is record
        mavg: MovingAverage_0.MovingAverage_0_self_t_list_t(0 to 3);
        y: complex_t(1 downto -34);
    end record;
    type DCRemoval_0_self_t_list_t is array (natural range <>) of DCRemoval_0.self_t;

    type self_t_const is record
        mavg: MovingAverage_0.MovingAverage_0_self_t_const_list_t_const(0 to 3);
        DELAY: integer;
    end record;
    type DCRemoval_0_self_t_const_list_t_const is array (natural range <>) of DCRemoval_0.self_t_const;

    procedure main(self:in self_t; self_next:inout self_t; constant self_const: self_t_const; x: complex_t(1 downto -34); ret_0:out complex_t(1 downto -34));
    function DCRemoval(mavg: MovingAverage_0.MovingAverage_0_self_t_list_t(0 to 3); y: complex_t(1 downto -34)) return self_t;
end package;

package body DCRemoval_0 is
    procedure main(self:in self_t; self_next:inout self_t; constant self_const: self_t_const; x: complex_t(1 downto -34); ret_0:out complex_t(1 downto -34)) is

        variable mav: MovingAverage_0.self_t;
        variable var: complex_t(1 downto -34);
        variable pyha_ret_0: complex_t(1 downto -34);
    begin
        -- run input signal over all the MA's
        var := resize(x, 0, -17, fixed_wrap, fixed_truncate);
        for \_i_\ in self.mavg'range loop
            MovingAverage_0.main(self.mavg(\_i_\), self_next.mavg(\_i_\), self_const.mavg(\_i_\), var, pyha_ret_0);
            var := resize(pyha_ret_0, 0, -17, fixed_wrap, fixed_truncate);

            -- dc-free signal
        end loop;
        self_next.y := resize(x - var, 0, -17, fixed_wrap, fixed_truncate);
        ret_0 := self.y;
        return;
    end procedure;

    function DCRemoval(mavg: MovingAverage_0.MovingAverage_0_self_t_list_t(0 to 3); y: complex_t(1 downto -34)) return self_t is
        -- limited constructor
        variable self: self_t;
    begin
        self.mavg := mavg;
        self.y := y;
        return self;
    end function;
end package body;
